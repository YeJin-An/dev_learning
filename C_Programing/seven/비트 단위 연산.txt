비트 단위 연산

1. 비트 단위 연산(bitwise operation)
-> 비트 단위 연산을 통해 
   1) 사용되는 메모리 공간을 줄인다.
   2) 성능의 항상을 기대할 수 있다.
2. 비트 연산자
~(not), &(and), |(or), ^(xor),
<<(left shift), >>(fight shift)

// 현재 대부분의 시스템에서는
   최상위 부호 비트(MSB)를 시프트 연산의 대상에서 
   제외하고 있습니다.!!

** 주의점
-> 비트 단위의 연산자는
   10진수로 연산이 아는 0과1로 계산이 되어
   10진수 연산이 아님을 기억하장!!

---------------------------------------------------------

음수의 표현
1. 정수의 표현
-> 부호있는 정수와 부호없는 정수로 생각가능.
: 부호없는 정수는 크기의 절댓값을 2진수로 변환하여 표현
: 부호있는 정수는 음수로 표현

2. 음수의 표현
-> 부호비트와 절댓값 방법
: 최상위 1비트로 부호를 표현하고, 나머지는 절댓값
-> 1의 보수
: 0을 1로 , 1을 0으로 바꾼다.
-> 2의 보수
: 1의 보수의 + 1을 해준다.

-----------------------------------------------------------

실수의 표현
1. 실수의 표현 방식
: 정수애 비해 훨씬 복잡하다

-> 고정 소수점(fixed point)방식
: 실수는 [부호 , 정수부 , 소수부]로 나뉨.
           1   +  15   +   16 = 32 (비트)
: 표현할 수 있는 범위가 한정되어 있음.

-> 부동 소수점(floation point)방식
: 하나의 실수를 [가수부]와 [지수부]로 나누어 표현하는 방식
: 현재 매우 큰 실수까지 표현할 수 있어
// 현재 대부분 부동 소수점 방식으로 실수를 표현한다.



2. IEEE 부동 소수점 방식
-> 32(bit) float  [부호 , 지수부 , 가수부]로 나뉨.
                    1   +   8   +   23   =   32 (비트)
-> 64(bit) double [부호 , 지수부 , 가수부]로 나뉨.
                    1   +  11   +   52   =   64 (비트)



3. 부동 소수점 방식의 오차
-> 부동 소수점 방식을 사용하면,
   고정 소수점 방식보다 더 많은 범위까지 표현할 수 있음.
-> 그런데 오차가 생긴다??
왜냐하면 10진수를 정확하게 표현할 수 없게 되기 때문이다.
// 실수를 표현하는 방법은 정확한 표현이 아닌 
                         근사치를 표현할 뿐임을 명심하자!!!

int i;
float sum = 0.1;
for(i = 0; i<1000; i++){
  sum += 0.1; }
printf(sum) // 100.099045
** 실수를 표현하는 방식은 
   어떤 언어에서든 오차가 발생은 기본적인 작업 일이다.!!
