포인터와 배열의 관계

-> 긴밀한 관계를 맺고 있음.
-> 어떤 부분은 서로 대체가능.

배열은 그 값을 변경할 수 없는 상수
라는 부분을 빼면 포인터와 같음.
// 배열의 이름은 constant pointer라고 함.

포인터 상수(constant pointer)__Array
-> 포인터 변수가 가리키고 있는 주소 값
-> 값을 변경할 수 없는 포인터
상수 포인터(pointer to constant)__Pointer
-> 상수를 가르키는 포인터를 의미

포인터를 배열의 이름처럼 사용할 수도 있음.
배열의 크기를 계산할 때, 배열과 포인터는 차이가 발생한다.

배열의 크기를 구하면 int형의 4바이트 * 3 = 12바이트
포인터 변수 자체의 크기 는 포인터 변수자체의 크기가 출력
// constant pointer VS pointer to constant


배열의 포인터 연산

배열의 이름으로 포인터 연산하여
각각의 배열 요소에 접근한다.

int arr[3] = {10,20,30};
printf("배열의 이름으로 요소접근",arr[0],arr[1],arr[2])
// 10 20 30
printf("포인터 연산으로 요소접근",*(arr+0),*(arr+1),*(arr+2))
// 10 20 30
*(arr + n) => 위치의 값을 읽습니다.!!

--> 다음의 공식은 다차원 배열까지 언제나 성립합니다.
arr[n] == *(arr + n)

*주의점
1. 배열의 크기를 넘어서 접근하지 말자
2. 포인터 연산으로 계산을 하다가 
   배열의 크기를 넘으면 C컴파일러는 오류로 발생하지 않음.
3. 즉. 포인 연산으로 계산하면 잘못된 결과를 반환하여
   C언어로 프로그래밍하면, 언제나 배열의 크기에도 주의하자!!

** 정리
포인터 상수(constant pointer)
상수 포인터(pointer to constant)
arr[n] == *(arr + n)

-------------------------------------------------------------

포인터 배열과 배열 포인터

포인터 배열
-> 배열 요소로 포인터 변수를 가지는 배열
-> 포인터 변수를 저장할 수 있는 배열
int num01 = 10, num02 = 20, num03 = 30;
int* arr[3] = {&num01,&num02,&num03};
arr_len = sizeof(arr)/sizeof(arr[0])



배열 포인터
-> 배열을 가리킬 수 있는 포인터
-> 배열 이름이 있는데, 배열 포인터를 정의하여 사용하는 이유는
    2차원 이상 배열을 가리킬 때, 포인터를 통해 
    배열과 같은 [인덱싱을 할 수 있도록 하기 위함]이다.
// 그렇기 때문에 포인터를 배열처럼 사용할수 있도록
   배열 포인터를 정의하여 사용한다.
* 1차원 배열에서의 포인터는 의미가 없음.
  2차원 이상의 배열에서만 의미를 가짐.
(arr + 1) == arr[1]

int arr[2][3] = {
  {10,20,30},
  {40,50,60}
};
printf(*arr[0],*arr[1])

sizeof(arr[0])/sizeof(타입)
int arr[2][3]; -> int형의 4바이트 행의길이3 
                  4 * 3=12
1.배열의 이름 arr는 int형 데이터를 가리키는 배열 포인터
2.배열 포인터는 포인터 연산 시 증감하는 값의 크기가 12바이트

배열 arr를 가리키는 배열 포인터는
int(*pArr)[3];
=> int arr01 [2][3];
=> int arr02 [3][3];
=> int arr03 [4][3];

int arr[2][3]={
  {10,20,30},
  {40,50,60}
};
int (*pArr)[3] = arr;
printf(arr[1][1], pArr[1][1]);


포인터 배열과 배열 포인터의 구분
1. int(*pArr)[3]; -> int형 데이터를 저장할 수 있는 2차원 배열
2. int* pArr[3];
-> int형 데이터를 가리킬 수 있는 포인터 
   변수를 모은 재열을 가리키는 포인터 배열
// 괄호의 유무가 중요하며,
   포인터 배열과 배열 포인터 사이의 차이점을 정확히
   이해하고 넘아가자!!

main()함수의 인수 전달
-> 제일 먼저 자동으로 호출되는 함수
-> 함수이기 때문에 인수전달받기, 반환값을 가질 수 있음.
void(OR int)main(int argc, char *argv[])
1. int argc는 
-> main()함수에 인수로 전달되는 문자열의 개수
2. char *argv[]는 
-> main()함수에 인수로 전달된 각각의 문자열이저장된 배열